ROLE: You are an expert Node.js/Express backend engineer with deep MongoDB experience. Your task: fully audit, implement, and harden the backend for a "Teacher Evaluation System" (students, instructors, dept heads, admins). Use the attached functional spec (roles, use-cases, business rules) as authority. Provide working code changes, tests, and migration/seed scripts. Prioritize correctness, security, performance, and a clear API contract for the existing React frontend.

GOALS (in priority order):
1. Ensure correct role-based auth (Student, Instructor, DeptHead, Admin, Superadmin if needed).
2. Implement evaluation workflows with one-evaluation-per-student-per-course enforcement and evaluation periods.
3. Build aggregation/report endpoints (per-instructor averages, trends, department reports).
4. Implement complaint handling, admin dashboards, scheduling for evaluations, and notifications.
5. Optimize DB schema, add indexes, and provide sample aggregation pipelines.
6. Add security (JWT, bcrypt, input validation, rate limiting, helmet), monitoring, logging, and caching where useful (Redis).
7. Produce automated tests (unit + integration) and database seed data.
8. Return a short migration plan and deploy checklist.

TECH DETAILS:
- Language: Node.js (>=18). Framework: Express.
- DB: MongoDB (Atlas). Use Mongoose for schemas.
- File uploads: Cloudinary for thumbnails or attachments.
- Auth: JWT access tokens + refresh tokens. Passwords hashed with bcrypt.
- Validation: express-validator + sanitize.
- Rate limiting: express-rate-limit; caching optional with Redis.
- Logging: winston for app logs; send errors to an error-tracking endpoint.
- CI: create sample test script (jest + supertest).
- APIs must follow REST conventions and return JSON with consistent envelope: { success, data, error }.

IMPLEMENTATION TASKS (concrete):
A. Schema models (Mongoose) to add/validate: User, Department, Course, Evaluation, Criteria, Complaint, Notification.
   - Unique constraints: evaluation: { courseId, studentId } unique.
   - Indexes: instructorId, courseId, createdAt, roles.
B. Core routes & controllers:
   - Auth: POST /api/auth/register, POST /api/auth/login, POST /api/auth/refresh, POST /api/auth/forgot, POST /api/auth/reset
   - Users: GET /api/users (admin), PUT /api/users/:id (admin/self), DELETE /api/users/:id (superadmin preventing self-delete)
   - Courses: CRUD
   - Evaluations: POST /api/evaluations (protected student; enforce BR1 & BR5), GET /api/evaluations/instructor/:id (deptHead/instructor/admin with access control), GET /api/evaluations/course/:id
   - Reports: GET /api/reports/instructor/:id?from=YYYY-MM-DD&to=YYYY-MM-DD (return averages, trend data), GET /api/reports/department/:id
   - Criteria: admin CRUD for evaluation criteria and weights
   - Complaints: POST /api/complaints, GET /api/complaints (admin)
C. Aggregations:
   - Instructor average across criteria, rating distribution, time-series (weekly/monthly averages).
D. Business rules enforcement:
   - BR1-BR15 mapped to API checks (student enrollment validation, time windows, one-eval-only).
E. Performance & production readiness:
   - Add pagination, limit + skip or cursor, and caching for expensive report endpoints (Redis).
   - Add indexes for aggregation paths and compound indexes where used.
F. Tests & seeds:
   - Provide jest+supertest examples for auth, evaluation submit, aggregation.
G. Devops checklist:
   - Env vars required, backup strategy, DB indexes migration steps, monitoring (metrics), TLS enforcement, CORS policy.

DELIVERABLES (return in response):
1. Files to add/patch: models/*.js, controllers/*.js, routes/*.js, middleware/auth.js, middleware/role.js, utils/aggregation.js, tests/*.spec.js
2. Example Mongoose schema snippets for each model.
3. Example route definitions with middleware usage.
4. Key aggregation queries and indexes.
5. Security checklist and simple deployment checklist.

When you implement code, include the exact file contents and indicate where to paste them in the codebase. If an endpoint requires the frontend to change, include the precise API contract (method, path, request body, response schema). Run brief unit-tests and show failing/passing outcomes. If something cannot be completed automatically, produce a step-by-step remediation plan.
